https://www.learnenough.com/git-tutorial/getting_started

# Git

[untracked/unstaged] -> git add -> [staged] -> git commit -> [local repo] -> git push -> [remote repo]

which git
git version
git config --get user.name
git config --get user.email

Not every file should be included in a Git snapshot. Here are some types of files that should be ignored:
  log files created by the web server
  database files
  configuration files that include passwords or API keys

Git gives us an easy way to ignore files. A hidden file in the project directory named .gitignore can specify a list of files that are never seen by Git. The rails new command creates a .gitignore file with defaults that include log files and database files. Later, when we add configuration files that include secrets, weâ€™ll update the .gitignore file.

git status

There are three forms of the git add command:
  git add foo.txt adds a file named foo.txt
  git add . adds all new files and changed files, except deleted files
  git add -A adds everything, including deletions

git commit -m "message"

git log
git log --oneline

git remote add origin https://github.com/YOUR_GITHUB_ACCOUNT/learn-rails.git
git push -u origin master
git push -u <remote> <branch> - push branch to remote
git push - pushes to default remote

Typical workflow
  git add -A
  git commit -m "wtv"
  git push origin master

  git commit --amend
  git show <SHA>
  git diff


## Branches and merging

One of the most powerful features of Git is its ability to make branches, which are effectively complete self-contained copies of the project source, together with the ability to merge one branch into another, thereby incorporating the changes into the original branch. The best thing about a branch is that you can make your changes to the project in isolation from the master copy of the code, and then merge your changes in only when they're done

git checkout -b foobranch --creates new branch and goes to it

git diff branch1 branch2
git diff branch1 -- automatically diffs against current branch

Once done edits on the branch - checkout to master
git checkout master
git merge branch2

git branch -d branch2 -- delete branch if merged
git branch -D branch2 -- delete branch if unmerged

## Recovering from errors

HEAD --> most recent commit
git checkout -f: forces git to checkout to HEAD

git checkout <SHA> -- reverts back to that commit
git checkout master to merge it back to master


## Collaborating
git push -- ensures all changes are on remote repo

Can add collaborators in repo settings on github

git clone -- makes a copy of a repo
git pull -- gets changes from remote repo

### Non-conflicting changes

git push will fail if the remote repo includes other info
git pull - will pull the changes and merge them with your edits and allow a commit message
can then push back and will have all changes on remote

### Conflicting changes
e.g. same line is edited 2 different ways

git push will fail
git pull will also fail and will tell you where conflict is

git detects a conflict, and puts your working copy in a special branch state: master|MERGING

can view and resolve the conflict in the editor. Commit the change, then branch will revert to master

Now the content is the same, but good idea for all users to pull the latest commit

### Pushing branches
e.g. using a separate branch for a bugfix

add a branch and make a commit
git push -u origin bugfix-branch -- pushes up to remote

git pull -- will tell you there's a new branch
  but it's associated with the remote repo, so won't show up in the local directory
  
git branch -- not shown
git branch -a -- shown: shows all branches
can checkout to the new branch and it will automatically track to working dir and then be able to push to remote


